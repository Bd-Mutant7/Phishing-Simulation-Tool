// ==================== LOAD ENVIRONMENT VARIABLES FIRST ====================
require('dotenv').config();

const express = require('express');
const bodyParser = require('body-parser');
const cookieParser = require('cookie-parser');
const path = require('path');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const { v4: uuidv4 } = require('uuid');
const nodemailer = require('nodemailer');
const db = require('./database/db');

const app = express();
const PORT = process.env.PORT || 3000;
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key-change-in-production';

// Debug: Log environment variables
console.log('[ENV] Checking environment configuration...');
console.log('[ENV] EMAIL_ENABLED:', process.env.EMAIL_ENABLED || 'NOT SET');
console.log('[ENV] SMTP_HOST:', process.env.SMTP_HOST || 'NOT SET');
console.log('[ENV] SMTP_USER:', process.env.SMTP_USER ? 'SET' : 'NOT SET');
console.log('[ENV] SMTP_PASSWORD:', process.env.SMTP_PASSWORD ? 'SET' : 'NOT SET');

// ==================== MIDDLEWARE DEFINITIONS ====================

// Authentication middleware
const authenticateAdmin = (req, res, next) => {
    const token = req.cookies.admin_token;
    if (!token) {
        return res.redirect('/admin/login');
    }

    try {
        const decoded = jwt.verify(token, JWT_SECRET);
        req.admin = decoded;
        next();
    } catch (err) {
        res.clearCookie('admin_token');
        return res.redirect('/admin/login');
    }
};

// ==================== EMAIL CONFIGURATION ====================

let emailTransporter = null;

// Initialize email transporter based on environment variables
function initializeEmailTransporter() {
    const emailEnabled = process.env.EMAIL_ENABLED === 'true';
    
    if (!emailEnabled) {
        console.log('[EMAIL] Email sending is disabled (EMAIL_ENABLED is not true)');
        return null;
    }
    
    const smtpHost = process.env.SMTP_HOST;
    const smtpPort = process.env.SMTP_PORT;
    const smtpUser = process.env.SMTP_USER;
    const smtpPassword = process.env.SMTP_PASSWORD;
    const smtpSecure = process.env.SMTP_SECURE === 'true';
    
    // Validate required email configuration
    if (!smtpHost || !smtpPort || !smtpUser || !smtpPassword) {
        console.warn('[EMAIL] Missing SMTP configuration. Check your .env file.');
        console.warn(`[EMAIL] SMTP_HOST: ${smtpHost || 'MISSING'}`);
        console.warn(`[EMAIL] SMTP_PORT: ${smtpPort || 'MISSING'}`);
        console.warn(`[EMAIL] SMTP_USER: ${smtpUser ? 'SET' : 'MISSING'}`);
        console.warn(`[EMAIL] SMTP_PASSWORD: ${smtpPassword ? 'SET' : 'MISSING'}`);
        return null;
    }
    
    try {
        const transporter = nodemailer.createTransport({
            host: smtpHost,
            port: parseInt(smtpPort),
            secure: smtpSecure,
            auth: {
                user: smtpUser,
                pass: smtpPassword
            },
            // Add timeout and SSL options
            connectionTimeout: 10000,
            greetingTimeout: 10000,
            socketTimeout: 10000,
            tls: {
                rejectUnauthorized: false
            }
        });
        
        console.log('[EMAIL] ✓ Email transporter initialized');
        console.log(`[EMAIL] Using SMTP: ${smtpHost}:${smtpPort}`);
        
        return transporter;
    } catch (error) {
        console.error('[EMAIL] ✗ Failed to create email transporter:', error.message);
        return null;
    }
}

// Function to send email
async function sendPhishingEmail(toEmail, firstName, campaign, trackingToken) {
    if (!emailTransporter) {
        console.warn(`[EMAIL] Cannot send email to ${toEmail} - transporter not initialized`);
        return false;
    }
    
    try {
        // Construct the phishing email
        const trackingPixelUrl = `${process.env.BASE_URL || `http://localhost:${PORT}`}/track/open/${trackingToken}`;
        const phishingLinkUrl = `${process.env.BASE_URL || `http://localhost:${PORT}`}/portal/${trackingToken}`;
        
        const mailOptions = {
            from: `"${campaign.sender_name}" <${campaign.sender_email}>`,
            to: toEmail,
            subject: campaign.subject_line,
            text: `Dear ${firstName},\n\n${campaign.email_body}\n\nClick here: ${phishingLinkUrl}\n\n`,
            html: `
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="UTF-8">
                    <title>${campaign.subject_line}</title>
                </head>
                <body>
                    <p>Dear ${firstName},</p>
                    ${campaign.email_body}
                    <p><a href="${phishingLinkUrl}">Click here</a></p>
                    <img src="${trackingPixelUrl}" width="1" height="1" alt="" />
                </body>
                </html>
            `
        };
        
        console.log(`[EMAIL] Attempting to send to: ${toEmail}`);
        const info = await emailTransporter.sendMail(mailOptions);
        
        console.log(`[EMAIL] Successfully sent to ${toEmail}:`, info.messageId);
        return true;
    } catch (error) {
        console.error(`[EMAIL] Failed to send to ${toEmail}:`, error.message);
        return false;
    }
}

// ==================== EXPRESS MIDDLEWARE ====================

app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));
app.use(cookieParser());
app.use(express.static('public'));
app.set('view engine', 'ejs');
app.set('views', path.join(__dirname, 'views'));

// ==================== ADMIN ROUTES ====================

// Admin login page
app.get('/admin/login', (req, res) => {
    res.render('admin/login', { error: null });
});

// Admin login handler
app.post('/admin/login', async (req, res) => {
    const { username, password } = req.body;

    try {
        const admin = await db.get('SELECT * FROM admins WHERE username = ?', [username]);
        
        if (!admin || !await bcrypt.compare(password, admin.password_hash)) {
            return res.render('admin/login', { error: 'Invalid credentials' });
        }

        const token = jwt.sign(
            { id: admin.id, username: admin.username },
            JWT_SECRET,
            { expiresIn: '8h' }
        );

        res.cookie('admin_token', token, { httpOnly: true, maxAge: 8 * 60 * 60 * 1000 });
        res.redirect('/admin/dashboard');
    } catch (err) {
        console.error('Login error:', err);
        res.render('admin/login', { error: 'System error. Please try again.' });
    }
});

// Test email endpoint (for debugging)
app.get('/admin/test-email', authenticateAdmin, async (req, res) => {
    try {
        if (!emailTransporter) {
            const errorDetails = `
                <h1>Email Configuration Error</h1>
                <h2>Environment Variables Status:</h2>
                <ul>
                    <li>EMAIL_ENABLED: ${process.env.EMAIL_ENABLED || 'NOT SET'}</li>
                    <li>SMTP_HOST: ${process.env.SMTP_HOST || 'NOT SET'}</li>
                    <li>SMTP_PORT: ${process.env.SMTP_PORT || 'NOT SET'}</li>
                    <li>SMTP_USER: ${process.env.SMTP_USER ? 'SET (hidden)' : 'NOT SET'}</li>
                    <li>SMTP_PASSWORD: ${process.env.SMTP_PASSWORD ? 'SET (hidden)' : 'NOT SET'}</li>
                </ul>
                <p>Check your .env file exists in: ${__dirname}</p>
                <p>File should contain:</p>
                <pre>
EMAIL_ENABLED=true
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_SECURE=false
SMTP_USER=spicespoiler@gmail.com
SMTP_PASSWORD=your-app-password
JWT_SECRET=your-secret
PORT=3000
                </pre>
                <p><a href="/admin/dashboard">Back to Dashboard</a></p>
            `;
            return res.status(500).send(errorDetails);
        }
        
        // Test the connection
        await emailTransporter.verify();
        
        // Send a test email to admin
        const testMailOptions = {
            from: process.env.SMTP_USER,
            to: process.env.SMTP_USER,
            subject: 'Phishing Simulator Test Email',
            text: 'This is a test email from your phishing simulation platform.',
            html: '<h1>Test Email</h1><p>This is a test email from your phishing simulation platform.</p>'
        };
        
        const info = await emailTransporter.sendMail(testMailOptions);
        
        res.send(`
            <h1>Email Test Successful!</h1>
            <p>Test email sent successfully.</p>
            <p>Message ID: ${info.messageId}</p>
            <p>Check your inbox at ${process.env.SMTP_USER}</p>
            <p><a href="/admin/dashboard">Back to Dashboard</a></p>
        `);
    } catch (error) {
        res.status(500).send(`
            <h1>Email Test Failed</h1>
            <p>Error: ${error.message}</p>
            <p>Check your .env file configuration and ensure your SMTP credentials are correct.</p>
            <p>For Gmail, make sure you're using an App Password if 2FA is enabled.</p>
            <p><a href="/admin/dashboard">Back to Dashboard</a></p>
        `);
    }
});

// Admin logout
app.get('/admin/logout', (req, res) => {
    res.clearCookie('admin_token');
    res.redirect('/admin/login');
});

// Admin dashboard
app.get('/admin/dashboard', authenticateAdmin, async (req, res) => {
    try {
        const campaigns = await db.all('SELECT * FROM campaigns ORDER BY created_at DESC LIMIT 10');
        const totalEmployees = await db.get('SELECT COUNT(*) as count FROM employees');
        const activeCampaigns = await db.get('SELECT COUNT(*) as count FROM campaigns WHERE status = "active"');
        
        // Check email status
        const emailStatus = emailTransporter ? 'Enabled' : 'Disabled';
        
        res.render('admin/dashboard', {
            admin: req.admin,
            campaigns,
            stats: {
                totalEmployees: totalEmployees.count,
                activeCampaigns: activeCampaigns.count
            },
            emailStatus
        });
    } catch (err) {
        console.error('Dashboard error:', err);
        res.status(500).send('Error loading dashboard');
    }
});

// Campaign management
app.get('/admin/campaigns', authenticateAdmin, async (req, res) => {
    try {
        const campaigns = await db.all('SELECT * FROM campaigns ORDER BY created_at DESC');
        res.render('admin/campaigns', { admin: req.admin, campaigns });
    } catch (err) {
        console.error('Campaigns error:', err);
        res.status(500).send('Error loading campaigns');
    }
});

// Create new campaign
app.get('/admin/campaigns/new', authenticateAdmin, (req, res) => {
    res.render('admin/campaign-new', { admin: req.admin });
});

app.post('/admin/campaigns', authenticateAdmin, async (req, res) => {
    const {
        name,
        description,
        scenario_type,
        sender_name,
        sender_email,
        subject_line,
        email_body
    } = req.body;

    try {
        const result = await db.run(
            `INSERT INTO campaigns (name, description, scenario_type, sender_name, sender_email, subject_line, email_body, created_by)
             VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
            [name, description, scenario_type, sender_name, sender_email, subject_line, email_body, req.admin.id]
        );

        res.redirect(`/admin/campaigns/${result.id}`);
    } catch (err) {
        console.error('Campaign creation error:', err);
        res.status(500).send('Error creating campaign');
    }
});

// View campaign details
app.get('/admin/campaigns/:id', authenticateAdmin, async (req, res) => {
    try {
        const campaign = await db.get('SELECT * FROM campaigns WHERE id = ?', [req.params.id]);
        
        if (!campaign) {
            return res.status(404).send('Campaign not found');
        }

        // Get campaign statistics
        const targets = await db.all(
            'SELECT * FROM campaign_targets WHERE campaign_id = ?',
            [req.params.id]
        );

        const events = await db.all(
            `SELECT ce.*, e.email, e.first_name, e.last_name 
             FROM campaign_events ce 
             JOIN employees e ON ce.employee_id = e.id 
             WHERE ce.campaign_id = ? 
             ORDER BY ce.occurred_at DESC`,
            [req.params.id]
        );

        // Calculate statistics
        const stats = {
            totalTargets: targets.length,
            emailsSent: targets.filter(t => t.sent_at).length,
            emailsOpened: new Set(events.filter(e => e.event_type === 'email_opened').map(e => e.employee_id)).size,
            linksClicked: new Set(events.filter(e => e.event_type === 'link_clicked').map(e => e.employee_id)).size,
            credentialsEntered: new Set(events.filter(e => e.event_type === 'credentials_entered').map(e => e.employee_id)).size,
            reported: new Set(events.filter(e => e.event_type === 'reported').map(e => e.employee_id)).size
        };

        res.render('admin/campaign-detail', {
            admin: req.admin,
            campaign,
            stats,
            events: events.slice(0, 50)
        });
    } catch (err) {
        console.error('Campaign detail error:', err);
        res.status(500).send('Error loading campaign details');
    }
});

// Launch campaign with REAL EMAILS
app.post('/admin/campaigns/:id/launch', authenticateAdmin, async (req, res) => {
    try {
        const campaign = await db.get('SELECT * FROM campaigns WHERE id = ?', [req.params.id]);
        
        if (!campaign) {
            return res.status(404).json({ error: 'Campaign not found' });
        }

        if (campaign.status === 'active') {
            return res.status(400).json({ error: 'Campaign already active' });
        }

        // Get all employees or specific targets
        const employees = await db.all('SELECT * FROM employees');

        // Launch campaign in background to avoid timeout
        launchCampaignBackground(req.params.id, campaign, employees);
        
        // Update campaign status immediately
        await db.run(
            'UPDATE campaigns SET status = ?, launched_at = CURRENT_TIMESTAMP WHERE id = ?',
            ['active', req.params.id]
        );

        res.json({ 
            success: true, 
            message: 'Campaign launched! Emails are being sent in the background.',
            emailEnabled: emailTransporter !== null
        });
    } catch (err) {
        console.error('Campaign launch error:', err);
        res.status(500).json({ error: 'Error launching campaign' });
    }
});

// ==================== CAMPAIGN DELETE ROUTE ====================

// Delete campaign
app.post('/admin/campaigns/:id/delete', authenticateAdmin, async (req, res) => {
    try {
        const campaignId = req.params.id;
        
        // First check if campaign exists
        const campaign = await db.get('SELECT * FROM campaigns WHERE id = ?', [campaignId]);
        
        if (!campaign) {
            return res.status(404).json({ error: 'Campaign not found' });
        }
        
        // Delete in correct order (due to foreign key constraints)
        await db.run('DELETE FROM campaign_targets WHERE campaign_id = ?', [campaignId]);
        await db.run('DELETE FROM campaign_events WHERE campaign_id = ?', [campaignId]);
        await db.run('DELETE FROM reports WHERE campaign_id = ?', [campaignId]);
        await db.run('DELETE FROM training_completions WHERE campaign_id = ?', [campaignId]);
        await db.run('DELETE FROM campaigns WHERE id = ?', [campaignId]);
        
        res.json({ 
            success: true, 
            message: `Campaign "${campaign.name}" deleted successfully` 
        });
    } catch (err) {
        console.error('Campaign delete error:', err);
        res.status(500).json({ error: 'Error deleting campaign' });
    }
});

// Background function to send emails
async function launchCampaignBackground(campaignId, campaign, employees) {
    console.log(`[CAMPAIGN] Starting email sending for campaign: ${campaign.name}`);
    
    let sentCount = 0;
    let failedCount = 0;
    
    for (const employee of employees) {
        const trackingToken = uuidv4();
        
        try {
            // Create tracking record
            await db.run(
                `INSERT INTO campaign_targets (campaign_id, employee_id, tracking_token, sent_at)
                 VALUES (?, ?, ?, CURRENT_TIMESTAMP)`,
                [campaignId, employee.id, trackingToken]
            );
            
            // Send real email if transporter is available
            if (emailTransporter) {
                const sent = await sendPhishingEmail(
                    employee.email,
                    employee.first_name,
                    campaign,
                    trackingToken
                );
                
                if (sent) {
                    sentCount++;
                } else {
                    failedCount++;
                }
            } else {
                // Simulation mode (no real emails)
                console.log(`[SIMULATION] Email would be sent to ${employee.email} with token ${trackingToken}`);
                sentCount++;
            }
            
            // Small delay to avoid rate limiting
            await new Promise(resolve => setTimeout(resolve, 100));
            
        } catch (error) {
            console.error(`[CAMPAIGN] Error processing ${employee.email}:`, error.message);
            failedCount++;
        }
    }
    
    console.log(`[CAMPAIGN] Email sending completed for ${campaign.name}`);
    console.log(`[CAMPAIGN] Successfully sent: ${sentCount}, Failed: ${failedCount}`);
    
    // Update campaign with final status
    try {
        // Check if column exists first to avoid errors
        const hasColumn = await db.get(`
            SELECT COUNT(*) as count FROM pragma_table_info('campaigns') 
            WHERE name = 'email_sent_count'
        `);
        
        if (hasColumn.count > 0) {
            await db.run(
                'UPDATE campaigns SET email_sent_count = ? WHERE id = ?',
                [sentCount, campaignId]
            );
        }
    } catch (error) {
        console.error('[CAMPAIGN] Error updating campaign stats:', error);
    }
}

// Employee management
app.get('/admin/employees', authenticateAdmin, async (req, res) => {
    try {
        const employees = await db.all('SELECT * FROM employees ORDER BY last_name, first_name');
        res.render('admin/employees', { admin: req.admin, employees });
    } catch (err) {
        console.error('Employees error:', err);
        res.status(500).send('Error loading employees');
    }
});

// Add employee
app.post('/admin/employees', authenticateAdmin, async (req, res) => {
    const { email, first_name, last_name, department, role } = req.body;

    try {
        await db.run(
            `INSERT INTO employees (email, first_name, last_name, department, role)
             VALUES (?, ?, ?, ?, ?)`,
            [email, first_name, last_name, department, role]
        );

        res.redirect('/admin/employees');
    } catch (err) {
        console.error('Employee creation error:', err);
        res.status(500).send('Error adding employee');
    }
});

// Bulk import employees (CSV)
app.post('/admin/employees/import', authenticateAdmin, async (req, res) => {
    // This would handle CSV parsing and bulk import
    res.json({ message: 'Bulk import endpoint - implement CSV parsing' });
});

// ==================== SIMULATION ROUTES ====================

// Email tracking pixel (1x1 transparent GIF)
app.get('/track/open/:token', async (req, res) => {
    const { token } = req.params;

    try {
        const target = await db.get(
            'SELECT * FROM campaign_targets WHERE tracking_token = ?',
            [token]
        );

        if (target) {
            await db.run(
                `INSERT INTO campaign_events (campaign_id, employee_id, tracking_token, event_type, ip_address, user_agent)
                 VALUES (?, ?, ?, ?, ?, ?)`,
                [target.campaign_id, target.employee_id, token, 'email_opened', req.ip, req.headers['user-agent']]
            );
        }
    } catch (err) {
        console.error('Email tracking error:', err);
    }

    // Send 1x1 transparent GIF
    const gif = Buffer.from('R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7', 'base64');
    res.writeHead(200, {
        'Content-Type': 'image/gif',
        'Content-Length': gif.length
    });
    res.end(gif);
});

// Phishing landing page
app.get('/portal/:token', async (req, res) => {
    const { token } = req.params;

    try {
        const target = await db.get(
            `SELECT ct.*, c.name as campaign_name, e.email, e.first_name, e.last_name
             FROM campaign_targets ct
             JOIN campaigns c ON ct.campaign_id = c.id
             JOIN employees e ON ct.employee_id = e.id
             WHERE ct.tracking_token = ?`,
            [token]
        );

        if (!target) {
            return res.status(404).send('Invalid link');
        }

        // Log link click
        await db.run(
            `INSERT INTO campaign_events (campaign_id, employee_id, tracking_token, event_type, ip_address, user_agent)
             VALUES (?, ?, ?, ?, ?, ?)`,
            [target.campaign_id, target.employee_id, token, 'link_clicked', req.ip, req.headers['user-agent']]
        );

        res.render('simulation/landing', { token, employeeName: target.first_name });
    } catch (err) {
        console.error('Landing page error:', err);
        res.status(500).send('Error loading page');
    }
});

// Credential submission (training capture)
app.post('/portal/:token/submit', async (req, res) => {
    const { token } = req.params;
    const { username, password } = req.body;

    try {
        const target = await db.get(
            'SELECT * FROM campaign_targets WHERE tracking_token = ?',
            [token]
        );

        if (!target) {
            return res.status(404).json({ error: 'Invalid token' });
        }

        // Log credential entry (NOT storing actual credentials)
        await db.run(
            `INSERT INTO campaign_events (campaign_id, employee_id, tracking_token, event_type, event_data, ip_address, user_agent)
             VALUES (?, ?, ?, ?, ?, ?, ?)`,
            [
                target.campaign_id,
                target.employee_id,
                token,
                'credentials_entered',
                JSON.stringify({ username_length: username?.length || 0 }),
                req.ip,
                req.headers['user-agent']
            ]
        );

        // Redirect to training page
        res.redirect(`/training/${token}`);
    } catch (err) {
        console.error('Credential submission error:', err);
        res.status(500).json({ error: 'System error' });
    }
});

// Report phishing
app.post('/report/:token', async (req, res) => {
    const { token } = req.params;
    const { method } = req.body;

    try {
        const target = await db.get(
            'SELECT * FROM campaign_targets WHERE tracking_token = ?',
            [token]
        );

        if (!target) {
            return res.status(404).json({ error: 'Invalid token' });
        }

        // Log report
        await db.run(
            `INSERT INTO campaign_events (campaign_id, employee_id, tracking_token, event_type, event_data, ip_address, user_agent)
             VALUES (?, ?, ?, ?, ?, ?, ?)`,
            [
                target.campaign_id,
                target.employee_id,
                token,
                'reported',
                JSON.stringify({ method: method || 'button' }),
                req.ip,
                req.headers['user-agent']
            ]
        );

        await db.run(
            `INSERT INTO reports (employee_id, campaign_id, report_method)
             VALUES (?, ?, ?)`,
            [target.employee_id, target.campaign_id, method || 'button']
        );

        res.json({ success: true, message: 'Thank you for reporting this suspicious message' });
    } catch (err) {
        console.error('Report error:', err);
        res.status(500).json({ error: 'System error' });
    }
});

// ==================== TRAINING ROUTES ====================

// Training page (shown after falling for phishing)
app.get('/training/:token', async (req, res) => {
    const { token } = req.params;

    try {
        const target = await db.get(
            `SELECT ct.*, c.name as campaign_name, c.scenario_type, e.first_name
             FROM campaign_targets ct
             JOIN campaigns c ON ct.campaign_id = c.id
             JOIN employees e ON ct.employee_id = e.id
             WHERE ct.tracking_token = ?`,
            [token]
        );

        if (!target) {
            return res.status(404).send('Invalid link');
        }

        res.render('training/landing', {
            employeeName: target.first_name,
            campaignName: target.campaign_name,
            scenarioType: target.scenario_type,
            token
        });
    } catch (err) {
        console.error('Training page error:', err);
        res.status(500).send('Error loading training');
    }
});

// Training completion
app.post('/training/:token/complete', async (req, res) => {
    const { token } = req.params;
    const { score } = req.body;

    try {
        const target = await db.get(
            'SELECT * FROM campaign_targets WHERE tracking_token = ?',
            [token]
        );

        if (!target) {
            return res.status(404).json({ error: 'Invalid token' });
        }

        await db.run(
            `INSERT INTO training_completions (employee_id, campaign_id, score)
             VALUES (?, ?, ?)`,
            [target.employee_id, target.campaign_id, score || 0]
        );

        res.json({ success: true });
    } catch (err) {
        console.error('Training completion error:', err);
        res.status(500).json({ error: 'System error' });
    }
});

// ==================== INITIALIZATION ====================

// Create default admin account
async function createDefaultAdmin() {
    try {
        const existingAdmin = await db.get('SELECT * FROM admins WHERE username = ?', ['admin']);
        
        if (!existingAdmin) {
            const passwordHash = await bcrypt.hash('ChangeMe123!', 10);
            await db.run(
                'INSERT INTO admins (username, password_hash, email) VALUES (?, ?, ?)',
                ['admin', passwordHash, 'admin@example.com']
            );
            console.log('Default admin created: username=admin, password=ChangeMe123!');
            console.log('IMPORTANT: Change this password immediately in production!');
        }
    } catch (err) {
        console.error('Error creating default admin:', err);
    }
}

// Verify email connection on startup
async function verifyEmailConnection() {
    if (!emailTransporter) {
        console.log('[EMAIL] Running in simulation mode (no emails will be sent)');
        console.log('[EMAIL] To enable real emails, set EMAIL_ENABLED=true in .env file');
        return;
    }
    
    try {
        await emailTransporter.verify();
        console.log('[EMAIL] ✓ SMTP connection verified successfully');
    } catch (error) {
        console.error('[EMAIL] ✗ SMTP connection failed:', error.message);
        console.error('[EMAIL] Check your .env configuration and SMTP credentials');
        emailTransporter = null;
    }
}

// ==================== DATABASE MIGRATION ====================

async function runDatabaseMigrations() {
    try {
        console.log('[DATABASE] Checking for required migrations...');
        
        // Check if email_sent_count column exists in campaigns table
        const hasEmailSentColumn = await db.get(`
            SELECT COUNT(*) as count FROM pragma_table_info('campaigns') 
            WHERE name = 'email_sent_count'
        `);
        
        if (hasEmailSentColumn.count === 0) {
            console.log('[DATABASE] Adding email_sent_count column to campaigns table...');
            await db.run('ALTER TABLE campaigns ADD COLUMN email_sent_count INTEGER DEFAULT 0');
            console.log('[DATABASE] ✓ Added email_sent_count column');
        }
        
        // Check if updated_at column exists in campaigns table
        const hasUpdatedAtColumn = await db.get(`
            SELECT COUNT(*) as count FROM pragma_table_info('campaigns') 
            WHERE name = 'updated_at'
        `);
        
        if (hasUpdatedAtColumn.count === 0) {
            console.log('[DATABASE] Adding updated_at column to campaigns table...');
            await db.run('ALTER TABLE campaigns ADD COLUMN updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP');
            console.log('[DATABASE] ✓ Added updated_at column');
        }
        
        console.log('[DATABASE] ✓ All migrations completed successfully');
    } catch (error) {
        console.error('[DATABASE] Migration error:', error.message);
    }
}

// Start server
app.listen(PORT, async () => {
    console.log(`Phishing Simulation Platform running on http://localhost:${PORT}`);
    console.log(`Admin login: http://localhost:${PORT}/admin/login`);
    
    // Initialize email transporter
    emailTransporter = initializeEmailTransporter();
    
    // Run database migrations
    await runDatabaseMigrations();
    
    // Verify email connection
    await verifyEmailConnection();
    
    // Create default admin
    await createDefaultAdmin();
    
    console.log('\n[QUICK TEST] To test email sending, visit:');
    console.log(`http://localhost:${PORT}/admin/test-email (after logging in)`);
});

// Graceful shutdown
process.on('SIGINT', async () => {
    console.log('\nShutting down gracefully...');
    await db.close();
    process.exit(0);
});
